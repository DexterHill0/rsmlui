#![doc = include_str!("../README.md")]

use std::fmt::Debug;

pub use drop_tree_derive::drop_tree;

/// A link in the drop-tree.
///
/// This struct holds:
/// - a token representing ownership of the current node
/// - a token representing ownership of its parent
///
/// This type is primarily generated by `#[drop_tree]` and should not
/// be constructed manually.
#[derive(Debug)]
pub struct OwnershipLink<S, P> {
    _self_token: S,
    _parent_token: P,
}

impl<S, P> OwnershipLink<S, P> {
    /// Gets an immutable reference to the token belonging to the struct owning this link.
    pub fn get_self(&self) -> &S {
        &self._self_token
    }

    /// Gets a mutable reference to the token belonging to the struct owning this link.
    pub fn get_mut_self(&mut self) -> &mut S {
        &mut self._self_token
    }
}

/// A node that participates in the drop-tree.
///
/// Types implementing this trait can appear in an ownership hierarchy.
/// Each node defines a zero-sized *marker token* (`SelfToken`) used as
/// a unique identifier for the type-erased nodes.
///
/// This trait is automatically implemented by `#[drop_tree]`.
#[diagnostic::on_unimplemented(
    message = "Cannot borrow from a node that is not part of a tree",
    label = "The borrowed struct may be missing `#[drop_tree(...)]`"
)]
pub trait OwnershipNode {
    /// Unique ZST marker token.
    type SelfToken;
}

/// Associates a node with the data passed to its destructor.
///
/// The context provides access to the node’s fields during drop.
pub trait DestructorContext<'ctx> {
    /// The type containing the node’s fields as mutable references with `'ctx` lifetime.
    type Ctx;
}

/// Convenience alias for a mutable destructor context reference.
///
/// This should be used in destructor functions to access the context type passed as an argument.
///
/// **Example:**
/// ```rs
/// #[drop_tree(destructor(my_destructor))]
/// struct Foo {
///     x: bool
/// }
///
/// fn my_destructor(ctx: DropCtx<Foo>) {
///     ctx.x;
/// }
/// ```
pub type DropCtx<'ctx, A> = &'ctx mut <A as DestructorContext<'ctx>>::Ctx;

// TODO: somehow get this working, so invalid destructor function shapes have better error reporting
// TODO: allow destructors with both 0 and 1 arguments
// #[diagnostic::on_unimplemented(
//     message = "Invalid destructor signature",
//     note = "A destructor must be a function of the form `fn()` or `fn(DropCtx<{Self}>)`",
//     note = "Example: `fn destroy(ctx: DropCtx<{Self}>)`"
// )]
// trait DestructorFn<'ctx, A> {
//     fn call(&mut self, a: &mut A);
// }

/// Marker trait used for type-erasing ownership handles.
///
/// This trait has no methods and is implemented for all types.
/// It exists solely to allow erasing the concrete type stored in an
/// ownership handle while retaining a unqiue marker for later casting back
/// to the concrete type soundly.
///
/// Erasure is used to prevent generics from propagating through the tree
/// while still enforcing correct parent-child relationships.
///
/// This shouldn't not need to be implemented manually.
pub trait ErasedToken<Marker> {}
impl<T: ?Sized, Marker> ErasedToken<Marker> for T {}

/// Concrete data used to construct an ownership node.
///
/// `OwnershipNodeData<M>` allows a child to provide its stored data while exposing
/// only its marker type `M` to the parent. This keeps ownership construction
/// generic and avoids leaking internal types.
///
/// This shouldn't need to be implemented manually.
pub trait OwnershipNodeData<M>: ErasedToken<M> + 'static {}
impl<T, M> OwnershipNodeData<M> for T where T: ErasedToken<M> + 'static {}

/// Synchronous ownership primitives.
///
/// This module contains the synchronous-only types used
/// to track ownership relationships between nodes in a drop-tree.
/// All unsafe code is confined here.
pub mod sync {
    use std::cell::UnsafeCell;
    use std::rc::Rc;

    use super::*;

    /// A reference-counted handle to a node’s storage.
    ///
    /// Internally, this is an `Rc<UnsafeCell<T>>`, which allows:
    /// - shared ownership via reference counting
    /// - interior mutability
    ///
    /// Users should never interact with this type directly.
    #[repr(transparent)]
    pub struct OwnershipHandle<T: ?Sized>(Rc<UnsafeCell<T>>);

    impl<T> OwnershipHandle<T> {
        fn new(value: T) -> Self {
            Self(Rc::new(UnsafeCell::new(value)))
        }
    }

    /// A type-erased version of [`OwnershipHandle<T>`].
    ///
    /// This hides the stored concrete type while preserving a unique marker
    /// that identifies the node in the ownership tree.
    ///
    /// Erased handles can be cloned, stored, and passed around without
    /// introducing generics, while still keeping the tree correct.
    ///
    /// The marker allows individual erased nodes to still have a concrete type
    /// preventing mismatched erased nodes from being cloned into the wrong resource
    /// which would be unsoundly cast at a later point.
    pub type ErasedOwnershipHandle<T> = OwnershipHandle<dyn ErasedToken<T>>;

    // the generic type is used to constrict which implementation of the trait can be passed as a parent
    // without it, all children would pass a parent with type `impl OwnershipBorrow` but that could point
    // to *any* parent, which would be unsound.
    // instead, the parent may be defined as `impl OwnershipBorrow<ParentMarker>` so only one struct satisfies
    // that implementation
    /// Allows a node to act as a parent in the ownership tree.
    ///
    /// This trait is implemented for types that can create child nodes
    /// borrowing from them. The marker type `S` identifies which parent
    /// token is produced.
    ///
    /// This trait is automatically implemented by `#[drop_tree]`.
    #[diagnostic::on_unimplemented(
        message = "Cannot borrow from this parent node",
        note = "The parent passed to `new_with_borrow` is not the expected owner for this node.",
        note = "This usually means one of the following:",
        note = "- The parent type is incorrect",
        note = "- The parent struct is missing `#[drop_tree(...)]`",
        note = "- You passed a field or wrapper instead of the owning node"
    )]
    pub trait OwnershipBorrow<M>: OwnershipNode<SelfToken = M> {
        /// Create a child ownership link borrowing from this node.
        fn ownership_borrow<Child: 'static, ChildData>(
            &self,
            child: ChildData,
        ) -> OwnershipLink<
            ErasedOwnershipHandle<Child::SelfToken>,
            ErasedOwnershipHandle<Self::SelfToken>,
        >
        where
            Child: OwnershipNode,
            ChildData: OwnershipNodeData<Child::SelfToken>;
    }

    impl<T> OwnershipHandle<T> {
        /// Erase the concrete type stored in this handle.
        ///
        /// The returned handle refers to the same allocation and participates
        /// in the same reference count.
        ///
        /// # Safety
        /// This operation is safe because:
        /// - the allocation is unchanged
        /// - `T: ErasedToken<M>` ensures a valid trait object
        /// - ownership is transferred exactly once
        pub fn into_erased<M>(self) -> ErasedOwnershipHandle<M>
        where
            T: ErasedToken<M> + 'static,
        {
            let rc = self.0;

            let raw: *const UnsafeCell<T> = Rc::into_raw(rc);
            let erased = raw as *const UnsafeCell<dyn ErasedToken<M>>;

            // SAFETY:
            // - `erased` points to the same allocation as `raw`
            // - `T: ErasedToken<M>`, so the vtable is valid
            // - ownership is transferred exactly once
            OwnershipHandle(unsafe { Rc::from_raw(erased) })
        }
    }

    impl<T: ?Sized> Clone for OwnershipHandle<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone())
        }
    }

    impl<T> Debug for OwnershipHandle<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "<handle>")
        }
    }

    impl<M> ErasedOwnershipHandle<M> {
        /// Access the underlying value by reinterpreting the erased handle.
        ///
        /// # Safety
        /// The caller must ensure that this handle was originally created
        /// from an `OwnershipHandle<T>` with the same `T`.
        pub unsafe fn unerased<T>(&self) -> &T {
            let ptr = Rc::as_ptr(&self.0) as *const UnsafeCell<T>;

            unsafe { &*(*ptr).get() }
        }

        /// Mutably access the underlying value.
        ///
        /// # Safety
        /// In addition to the requirements of [`unerased`], the caller must
        /// ensure no other mutable borrows are active.
        pub unsafe fn unerased_mut<T>(&mut self) -> &mut T {
            let ptr = Rc::as_ptr(&self.0) as *const UnsafeCell<T>;

            unsafe { &mut *(*ptr).get() }
        }
    }

    impl<M> OwnershipLink<ErasedOwnershipHandle<M>, ()> {
        /// Create the root of an ownership tree.
        ///
        /// The root has no parent and owns its value outright
        /// (parent is just `()`).
        pub fn new_root<T: 'static>(_self: T) -> Self {
            let inner = OwnershipHandle::new(_self);
            let erased: ErasedOwnershipHandle<M> = inner.into_erased();

            Self {
                _self_token: erased,
                _parent_token: (),
            }
        }
    }

    impl<M, P> OwnershipLink<ErasedOwnershipHandle<M>, P> {
        /// Create a child node borrowing from this link.
        ///
        /// The returned link ensures the parent remains alive
        /// for at least as long as the child.
        pub fn borrow_with_child<D, CM>(
            &self,
            child: D,
        ) -> OwnershipLink<ErasedOwnershipHandle<CM>, ErasedOwnershipHandle<M>>
        where
            D: OwnershipNodeData<CM>,
            CM: 'static,
        {
            let inner = OwnershipHandle::new(child);
            let erased: ErasedOwnershipHandle<CM> = inner.into_erased();

            OwnershipLink {
                _self_token: erased,
                _parent_token: self._self_token.clone(),
            }
        }
    }
}
