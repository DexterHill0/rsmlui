use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

use cxx_build::CFG;

// TODO: mutually exclusive but dont kill rust analyzer
// #[cfg(all(feature = "freetype", feature = "cosmic-text"))]
// compile_error!("Features `freetype` and `cosmic-text` are mutually exclusive. Enable only one.");

const RSMLUI_SYS_LIB_NAME: &str = "rsmlui_dummy";
const RMLUI_OUTPUT_NAME: &str = "rmlui";

#[rustfmt::skip]
const DEFINTIONS: &[(&str, &str)] = &[
    #[cfg(feature = "freetype")]
    ("RMLUI_FONT_ENGINE", "freetype"),

    #[cfg(not(feature = "freetype"))]
    ("RMLUI_FONT_ENGINE", "none"),

    #[cfg(not(feature = "system-win32"))]
    ("RMLUI_DISABLE_INCLUDE_WINDOWS", "ON"),

    ("BUILD_SHARED_LIBS", "OFF"),
    ("RMLUI_STATIC_LIB", "ON"),
    ("RMLUI_DEBUG", "ON"),
    ("RMLUI_NO_THIRDPARTY_CONTAINERS", "ON"),
    ("UNICODE", "ON"),
    ("_UNICODE", "ON"),
    ("WIN32_LEAN_AND_MEAN", "ON"),
];

fn build_rmlui_renderer(bridge: &mut cc::Build) {
    #[cfg(feature = "system-win32")]
    {
        bridge.file("RmlUi/Backends/RmlUi_Platform_Win32.cpp");
    };
    #[cfg(feature = "renderer-gl2")]
    {
        bridge.file("RmlUi/Backends/RmlUi_Renderer_GL2.cpp");
    };

    #[cfg(all(feature = "system-win32", feature = "renderer-gl2"))]
    {
        bridge.file("RmlUi/Backends/RmlUi_Backend_Win32_Gl2.cpp");
    };

    // required for vfuncs
    bridge.file("RmlUi/Source/Core/RenderInterface.cpp");

    // TODO: custom backend
    // #[cfg(not(feature = "backend_glfw_gl3"))]
}

// globs the include headers and creates a dummy cpp source file
// mainly used for intellisense purposes
fn create_dummy_sources_from_headers(dummy_dir: &Path, ignore: &[&str]) -> Vec<String> {
    let mut cpp_files = Vec::new();

    if dummy_dir.exists() {
        fs::remove_dir_all(&dummy_dir).unwrap();
    }
    fs::create_dir_all(&dummy_dir).unwrap();

    for entry in glob::glob("./src/include/rsmlui/**/*.h").expect("failed to read glob pattern") {
        match entry {
            Ok(path) => {
                let filename = path.file_name().unwrap().to_str().unwrap();

                // skip bindgen bindings file
                if ignore.contains(&filename) {
                    continue;
                }

                // generate a .cpp file per header
                let file_stem = path
                    .file_stem()
                    .expect("header has no file_stem")
                    .to_string_lossy();
                let cpp_path = dummy_dir.join(format!("{}.cpp", file_stem));

                let relative_include = path
                    .strip_prefix("src/include")
                    .unwrap()
                    .to_string_lossy()
                    .replace("\\", "/");

                let mut cpp_file =
                    fs::File::create(&cpp_path).expect("failed to create dummy cpp file");

                writeln!(
                    cpp_file,
                    "// !!! AUTOMATICALLY GENERATED BY BUILD FILE DO NOT MODIFY MANUALLY !!!\n"
                )
                .unwrap();
                writeln!(cpp_file, "#include \"rust/cxx.h\"").unwrap();
                writeln!(cpp_file, "#include \"{}\"", relative_include).unwrap();

                cpp_files.push(cpp_path.to_string_lossy().into_owned());
            },
            Err(e) => println!("failed to glob file: {:?}", e),
        }
    }

    cpp_files
}

fn main() {
    // we already sorta have a prefix because of the `include/rsmlui` folder structure, so no need for another
    CFG.include_prefix = "";

    let rust_out_dir: PathBuf = std::env::var("OUT_DIR").unwrap().into();

    let cxx_include_dir = rust_out_dir.join("cxxbridge/include");

    let bindings = bindgen::Builder::default()
        .header("src/include/rsmlui/Bindings.h")
        .clang_arg("-x")
        .clang_arg("c++")
        .clang_arg("-std=c++20")
        .clang_arg(format!("-I{}", cxx_include_dir.display()))
        .clang_arg("-I./src/include")
        .clang_arg("-I./RmlUi/Include")
        .clang_arg("-I./RmlUi/Backends")
        .allowlist_type("Rml::Input::KeyIdentifier")
        .allowlist_type("Rml::Input::KeyModifier")
        .allowlist_type("Rml::ClipMaskOperation")
        .allowlist_type("Rml::BlendMode")
        .allowlist_type("Rml::Vertex")
        .allowlist_type("Rml::Vector2f")
        .allowlist_type("Rml::Vector2i")
        .allowlist_type("Rml::Log_Type")
        .allowlist_var("")
        .allowlist_function("")
        .bitfield_enum("Rml::Input::KeyModifier")
        .default_enum_style(bindgen::EnumVariation::Rust {
            non_exhaustive: true,
        })
        .translate_enum_integer_types(true)
        .respect_cxx_access_specs(true)
        .flexarray_dst(true)
        .raw_line("#![allow(unused_variables, non_camel_case_types)]")
        .clang_args(
            DEFINTIONS
                .iter()
                .map(|(key, value)| format!("-D{key}={}", *value)),
        )
        .generate()
        .expect("Unable to generate bindings");

    bindings.write_to_file("src/bindings.rs").unwrap();

    let cpp_files_dir: PathBuf = "dummy_sources".into();
    let mut cpp_files = create_dummy_sources_from_headers(&cpp_files_dir, &["Bindings.h"]);

    // cpp_files.push("src/cxx/SystemInterface.cpp".into());

    // cxx MUST come before cmake so the codegenned headers exist
    // when cmake does the build, as these headers are part of the `compile_commands.json`
    // used for intellisense
    let mut bridge = cxx_build::bridges(&[
        "src/ffi/core.rs",
        "src/ffi/render_interface.rs",
        "src/ffi/system_interface.rs",
        "src/ffi/backend.rs",
        "src/ffi/context.rs",
        "src/ffi/element_document.rs",
    ]);

    for file in cpp_files {
        bridge.file(file);
    }

    bridge
        .flag_if_supported("/std:c++20")
        .include(&cxx_include_dir)
        .include("./src/include")
        .include("./RmlUi/Include")
        .include("./RmlUi/Backends");

    for (key, value) in DEFINTIONS {
        bridge.define(key, *value);
    }

    build_rmlui_renderer(&mut bridge);

    bridge.compile("rsmlui-cxx");

    #[cfg(debug_assertions)]
    let cmake_build_type = "RelWithDebInfo";
    #[cfg(not(debug_assertions))]
    let cmake_build_type = "Release";

    let mut cmake_cfg = cmake::Config::new(".");

    cmake_cfg.build_target("all");
    cmake_cfg.generator("Ninja");

    cmake_cfg
        .define("RMLUI_OUTPUT_NAME", RMLUI_OUTPUT_NAME)
        .define("RSMLUI_SYS_LIB_NAME", RSMLUI_SYS_LIB_NAME)
        .define("RSMLUI_CXX_INCLUDE_DIR", cxx_include_dir)
        .define(
            "RSMLUI_DUMMY_SOURCES_DIR",
            cpp_files_dir.display().to_string(),
        )
        .define("CMAKE_EXPORT_COMPILE_COMMANDS", "ON")
        .define("CMAKE_MSVC_RUNTIME_LIBRARY", "MultiThreadedDLL");

    for (key, value) in DEFINTIONS {
        cmake_cfg.define(key, *value);
    }

    cmake_cfg.profile(cmake_build_type);

    let cmake_dst = cmake_cfg.build();

    let cmake_build_dir = cmake_dst.join("build");

    let copy_src = cmake_build_dir.join("compile_commands.json");
    let copy_dest =
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap()).join("compile_commands.json");

    std::fs::copy(copy_src, copy_dest).expect("failed to copy compile commands");

    println!(
        "cargo:rustc-link-search=native={}",
        cmake_build_dir.display()
    );

    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=CMakeLists.txt");
    println!("cargo:rerun-if-changed=src/include/rsmlui");

    println!("cargo:rustc-link-lib=static={}", RSMLUI_SYS_LIB_NAME);
    println!("cargo:rustc-link-lib=static={}", RMLUI_OUTPUT_NAME);
    println!("cargo:rustc-link-lib=static={}_debugger", RMLUI_OUTPUT_NAME);

    #[cfg(feature = "freetype")]
    {
        println!("cargo:rustc-link-lib=static=bz2_static");
        println!("cargo:rustc-link-lib=static=brotlicommon");
        println!("cargo:rustc-link-lib=static=brotlienc");
        println!("cargo:rustc-link-lib=static=brotlidec");
        println!("cargo:rustc-link-lib=static=harfbuzz");
        println!("cargo:rustc-link-lib=static=zlibstatic");
        println!("cargo:rustc-link-lib=static=libpng16_static");
        println!("cargo:rustc-link-lib=static=freetype");
    }

    #[cfg(target_os = "windows")]
    {
        println!("cargo:rustc-link-lib=user32");
        println!("cargo:rustc-link-lib=opengl32");
        println!("cargo:rustc-link-lib=gdi32");
    }
}
